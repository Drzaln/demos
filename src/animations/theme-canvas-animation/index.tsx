import type { SkiaValue } from '@shopify/react-native-skia';import {  Group,  Rect,  runTiming,  Skia,  useComputedValue,  useFont,  useValue,  Text,} from '@shopify/react-native-skia';import { useCallback } from 'react';import Touchable from 'react-native-skia-gesture';import { useWindowDimensions } from 'react-native';import { SelectableSquareContainer } from './selectable-square';const SQUARE_SIZE = 35;const APP_TEXT = 'THEME';const colors = [  { background: '#F7FFF7', text: '#373737' },  { background: '#4ECDC4', text: '#2C2C2C' },  { background: '#1A535C', text: '#E8E8E8' },  { background: '#EE6C4D', text: '#D4D2D2' },  { background: '#F38D68', text: '#2C2C2C' },  { background: '#902D41', text: '#DEDEDE' },];const ThemeScreen = () => {  const { height: canvasHeight, width: canvasWidth } = useWindowDimensions();  const coordinates = useComputedValue(() => {    const squares = [      { offsetX: -1, offsetY: 0 },      { offsetX: 0, offsetY: 0 },      { offsetX: 1, offsetY: 0 },      { offsetX: 0, offsetY: 1 },      { offsetX: -1, offsetY: 1 },      { offsetX: 1, offsetY: 1 },    ];    return squares.map(({ offsetX, offsetY }) => ({      cx: canvasWidth / 2 - SQUARE_SIZE / 2 + offsetX * SQUARE_SIZE * 2,      cy: canvasHeight / 2 - SQUARE_SIZE / 2 + offsetY * SQUARE_SIZE * 2,    }));  }, [canvasWidth, canvasHeight]);  const selectedIndex = useValue(0);  const previousSelectedIndex = useValue(0);  const selectedBackgroundColor = useComputedValue(() => {    return colors[selectedIndex.current]?.background || 'black';  }, [colors, selectedIndex]);  const previousSelectedBackgroundColor = useComputedValue(() => {    return colors[previousSelectedIndex.current]?.background || 'black';  }, [colors, previousSelectedIndex]);  const radius = useValue(0);  const clipPath = useComputedValue(() => {    const path = Skia.Path.Make();    const x = coordinates.current[selectedIndex.current]?.cx ?? 0;    const y = coordinates.current[selectedIndex.current]?.cy ?? 0;    path.addCircle(x + SQUARE_SIZE / 2, y + SQUARE_SIZE / 2, radius.current);    return path;  }, [selectedIndex, coordinates, radius]);  const onSelectSquare = useCallback(    (index: number) => {      if (index === selectedIndex.current) return;      radius.current = 0;      runTiming(        radius,        canvasHeight,        {          duration: 500,        },        endValue => {          const isFinished = endValue === canvasHeight;          if (isFinished) {            previousSelectedIndex.current = index;            radius.current = 0;          }        },      );      previousSelectedIndex.current = selectedIndex.current;      selectedIndex.current = index;    },    [selectedIndex, previousSelectedIndex, canvasHeight, radius],  );  // eslint-disable-next-line @typescript-eslint/no-var-requires  const font = useFont(require('../../../assets/fonts/outfit.ttf'), 40);  const textY = useComputedValue(() => {    return canvasHeight / 2 - 65;  }, [canvasHeight]);  const textX = useComputedValue(() => {    return canvasWidth / 2 - (font?.getTextWidth(APP_TEXT) || 0) / 2;  }, [canvasWidth, font]);  const selectedTextColor = useComputedValue(() => {    return colors[selectedIndex.current]?.text || 'black';  }, [colors, selectedIndex]);  const previousSelectedTextColor = useComputedValue(() => {    return colors[previousSelectedIndex.current]?.text || 'black';  }, [colors, previousSelectedIndex]);  const BackgroundComponent = useCallback(    ({      backgroundColor,      textColor,    }: {      backgroundColor: SkiaValue<string>;      textColor: SkiaValue<string>;    }) => {      return (        <>          <Rect            x={0}            y={0}            width={canvasWidth}            height={canvasHeight}            color={backgroundColor}          />          {font && (            <Text              font={font}              text={APP_TEXT}              color={textColor}              x={textX}              y={textY}            />          )}        </>      );    },    [canvasHeight, canvasWidth, font, textX, textY],  );  return (    <Group>      {BackgroundComponent({        backgroundColor: previousSelectedBackgroundColor,        textColor: previousSelectedTextColor,      })}      <Group clip={clipPath}>        {BackgroundComponent({          backgroundColor: selectedBackgroundColor,          textColor: selectedTextColor,        })}      </Group>      {coordinates.current.map((_, index) => (        <SelectableSquareContainer          color={colors[index]?.background || 'black'}          key={index}          size={SQUARE_SIZE}          coordinates={coordinates}          selectedIndex={selectedIndex}          borderColor={colors[index]?.text || 'white'}          index={index}          onSelect={() => {            onSelectSquare(index);          }}        />      ))}    </Group>  );};export const ThemeCanvasAnimation = () => {  return (    <Touchable.Canvas style={{ flex: 1 }}>      <ThemeScreen />    </Touchable.Canvas>  );};